package org.jooq.mcve.test.java.postgres;

import org.jooq.Condition;
import org.jooq.DSLContext;
import org.jooq.SQLDialect;
import org.jooq.impl.DSL;
import org.jooq.tools.JooqLogger;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.shaded.org.apache.commons.lang3.StringUtils;
import org.testcontainers.utility.ResourceReaper;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.List;
import java.util.Properties;

import static org.jooq.impl.DSL.any;
import static org.jooq.impl.DSL.array;
import static org.jooq.impl.DSL.or;
import static org.jooq.impl.DSL.select;
import static org.jooq.impl.DSL.trueCondition;
import static org.jooq.impl.DSL.value;
import static org.jooq.mcve.java.postgres.Tables.TEST;
import static org.junit.Assert.assertEquals;

public class JavaTest {

    static JooqLogger log = JooqLogger.getLogger(JavaTest.class);
    static PostgreSQLContainer<?> db;
    static Connection connection;
    static DSLContext ctx;

    @BeforeClass
    public static void init() throws SQLException {
        if (System.getProperty("db.url") == null) {
            db = new org.testcontainers.containers.PostgreSQLContainer<>("postgres:latest")
                    .withUsername("str")
                    .withDatabaseName("postgres")
                    .withPassword("str")
                    .withInitScript("db/migration/init.sql");

            db.start();
            System.setProperty("db.url", db.getJdbcUrl());
            System.setProperty("db.username", db.getUsername());
            System.setProperty("db.password", db.getPassword());
        }

        Properties properties = new Properties();
        properties.setProperty("username", "str");
        properties.setProperty("password", "str");

        log.info("Connecting");
        connection = DriverManager.getConnection(
                System.getProperty("db.url"),
                System.getProperty("db.username"),
                System.getProperty("db.password")
        );

        ctx = DSL.using(connection, SQLDialect.POSTGRES);

        // Use JDBC directly instead of jOOQ to avoid DEBUG logging all of this
        try (Statement s = connection.createStatement()) {
            log.info("Finished setup");
        }
    }

    @AfterClass
    public static void end() {
        if (db != null) {
            ResourceReaper.instance().stopAndRemoveContainer(db.getContainerId(), db.getDockerImageName());
        }
    }

    @Before
    public void setup() throws Exception {
        ctx.delete(TEST).execute();
    }

    @After
    public void after() throws Exception {
    }

    @Test
    public void mcveTest() {
        assertEquals(6,
                ctx.insertInto(TEST)
                        .columns(TEST.CD, TEST.CODE, TEST.PARENT_CODE)
                        /*
                         * ""
                         * - lvl1
                         *   - lvl2-a
                         *   - lvl2-b
                         *       - lvl3
                         * - lvl1-1
                         * */
                        .values(0, "", null)
                        .values(1, "lvl1", new String[]{""})
                        .values(2, "lvl2-a", new String[]{"", "lvl1"})
                        .values(3, "lvl2-b", new String[]{"", "lvl1"})
                        .values(4, "lvl3", new String[]{"", "lvl1", "lvl2-b"})
                        .values(5, "lvl1-1", new String[]{""})
                        .execute()
        );

        /* in jooq 3.18.7
        org.jooq.exception.DataAccessException: SQL [select "mcve"."test"."code", "mcve"."test"."parent_code" from "mcve"."test" where ("mcve"."test"."code" <> ? and (? = any ("mcve"."test"."parent_code") or "mcve"."test"."code" = (select "mcve"."test"."parent_code" from "mcve"."test" where "mcve"."test"."code" = ?)))]; ERROR: operator does not exist: character varying = character varying[]
  Indice : No operator matches the given name and argument types. You might need to add explicit type casts.
  Position : 179*/
        assertEquals(List.of("lvl2-a", "lvl2-b", "lvl3"), fetchRelated(false, "lvl1"));
        assertEquals(List.of("", "lvl2-a", "lvl2-b", "lvl3"), fetchRelated(true, "lvl1"));

        assertEquals(List.of("lvl1"), fetchRelated(false, "lvl2-a"));
        assertEquals(List.of("", "lvl1"), fetchRelated(true, "lvl2-a"));

        assertEquals(List.of("lvl1", "lvl2-b"), fetchRelated(false, "lvl3"));
        assertEquals(List.of("", "lvl1", "lvl2-b"), fetchRelated(true, "lvl3"));

        assertEquals(List.of(), fetchRelated(false, "lvl1-1"));
        assertEquals(List.of(""), fetchRelated(true, "lvl1-1"));

        assertEquals(List.of(""), fetchRelated(true, "unknown"));
    }

    private List<String> fetchRelated(boolean includeRoot, String code) {
        Condition condition = includeRoot ? trueCondition() : TEST.CODE.ne("");
        if (StringUtils.isNotEmpty(code)) {
            condition = condition.and(
                    or(
                            // get children
                            value(code).equal(any(TEST.PARENT_CODE)),
                            // get parents
                            TEST.CODE.equal(any(array(select(TEST.PARENT_CODE)
                                    .from(TEST)
                                    .where(TEST.CODE.equal(code))
                                    .asField())))
                    )
            );
        }

        return ctx.select(TEST.CODE, TEST.PARENT_CODE)
                .from(TEST)
                .where(condition)
                .fetch(TEST.CODE);
    }
}
